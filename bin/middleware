#!/usr/bin/env ruby
require 'ffi-rzmq'
require 'logger'
require 'optparse'

class Middleware
  def initialize(options)
    @recv_count = 0
    @send_count = 0
    @clients = {}

    $stdout.sync = true
    @logger = Logger.new(STDOUT)
    @logger.level = Logger::INFO

    @context = ZMQ::Context.new
    @socket = @context.socket(ZMQ::ROUTER)

    if options.include?(:curve_private_key)
      @logger.debug "enabling curve with private key '#{options[:curve_private_key]}'"
      private_key = IO.read(options[:curve_private_key]).chomp
      assert_zeromq(@socket.setsockopt(ZMQ::CURVE_SERVER, 1))
      assert_zeromq(@socket.setsockopt(ZMQ::CURVE_SECRETKEY, private_key))
    end

    # start listening to the network
    @logger.debug "binding #{options[:bind]}"
    assert_zeromq(@socket.bind(options[:bind]))

    Thread.new do
      status_thread
    end
  end

  def main_loop
    @logger.info "going into mainloop"

    poller = ZMQ::Poller.new
    assert_zeromq(poller.register_readable(@socket))

    while true
      # TODO - figure out next ping, and set polling based on this
      @logger.debug "polling for messages"
      poller.poll
      @logger.debug "poller woke up"

      if poller.readables.empty?
        # Here is whete we should put the sending of PING
        @logger.debug 'time to send some pings'
      else
        @logger.debug 'message available'
        # Message to route
        source, message = read_message

        begin
          verb = message.shift

          case verb
          when 'CONNECT'
            options = Hash[*message]
            # TODO(richardc): versioncmp
            @logger.info "CONNECT '#{source}' #{options.inspect}"

            @clients[source] = {
              :id => source,
              :ttl => Integer(options['TTL']),
              :subscriptions => [],
              :next_heartbeat => nil, # may be set at end of loop
            }

          when 'DISCONNECT'
            @logger.info "DISCONNECT '#{source}'"
            @clients.delete(source)
            next # skip the 'update last heard'

          when 'SUB'
            @clients[source][:subscriptions] += message

          when 'UNSUB'
            @clients[source][:subscriptions] -= message

          when 'PUT'
            topic = message.first
            count = 0
            @clients.values.select { |x| x[:subscriptions].include?(topic) }.each do |client|
              count += 1
              send_message(client[:id], 'MESSAGE', *message)
            end
            @logger.info "forwarded message on '#{topic}' from '#{source}' to #{count} recipients"

          when 'PING'
            send_message(source, 'PONG', *message)

          when 'PONG'
            # possibly update state to indicate an outstanding PING has been acked

          else
            @logger.error "Don't know how to handle '#{verb}', saying FAIL"
            send_message(source, 'ERROR', 'Unknown verb')
          end
        rescue Exception => e
          send_message(source, 'ERROR', "caught exception: #{e}")
        end

        if @clients[source] && @clients[source][:ttl]
          @clients[source][:next_heartbeat] = Time.now + (@clients[source][:ttl] / 1000.0)
        end
      end
    end
  end

  private

  def status_thread
    @logger.info "Starting status thread"

    lastmsg = ''
    while true
      newmsg = "Currently managing #{@clients.count} clients. Recv: #{@recv_count}. Sent #{@send_count}."
      if lastmsg != newmsg
        @logger.info newmsg
        lastmsg = newmsg
      end
      sleep 2
    end
  end

  def read_message
    @logger.debug 'going to read message'
    message = []
    assert_zeromq(@socket.recv_strings(message))
    source = message.slice!(0,2)[0]

    @recv_count += 1
    @logger.debug "got #{message.inspect} from #{source.inspect}"
    return source, message
  end

  def send_message(target, *message)
    @logger.debug "sending #{message.inspect} to #{target.inspect}"
    @socket.send_strings([ target, '', *message ], ZMQ::DONTWAIT)
    @logger.debug 'sent message'
    @send_count += 1
  end

  def assert_zeromq(rc)
    return if ZMQ::Util.resultcode_ok?(rc)
    raise "Operation failed, errno [#{ZMQ::Util.errno}] description [#{ZMQ::Util.error_string}]"
  end
end


options = {
  :bind  => 'tcp://*:61616',
}
OptionParser.new do |opts|
  opts.banner = "Usage: middleware [options]"

  opts.on('--bind', 'Address to bind') do |v|
    options[:bind] = v
  end

  opts.on('--curve-private-key=s', 'The curve privatekey') do |v|
    options[:curve_private_key] = v
  end
end.parse!

Middleware.new(options).main_loop

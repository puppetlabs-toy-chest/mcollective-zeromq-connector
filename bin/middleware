#!/usr/bin/env ruby
require 'ffi-rzmq'
require 'logger'
require 'optparse'

class Middleware
  def initialize(options)
    @clients = {}

    @logger = Logger.new(STDOUT)
    @logger.level = Logger::DEBUG

    @context = ZMQ::Context.new
    @socket = @context.socket(ZMQ::ROUTER)

    if options.include?(:curve_private_key)
      @logger.debug "enabling curve with private key '#{options[:curve_private_key]}'"
      private_key = IO.read(options[:curve_private_key]).chomp
      assert_zeromq(@socket.setsockopt(ZMQ::CURVE_SERVER, 1))
      assert_zeromq(@socket.setsockopt(ZMQ::CURVE_SECRETKEY, private_key))
    end

    # start listening to the network
    @logger.debug "binding #{options[:bind]}"
    assert_zeromq(@socket.bind(options[:bind]))

    Thread.new do
      status_thread
    end
  end

  def main_loop
    @logger.info "going into mainloop"

    poller = ZMQ::Poller.new
    poller.register_readable(@socket)

    while true
      @logger.info "waiting for a message"
      poller.poll

      @logger.info "poller woke up"

      if poller.readables.size > 0
        # Message to route
        source, message = read_message

        verb = message.shift

        case verb
        when 'CONNECT'
          options = Hash[message]
          @clients[source] = {
            :options => options,
            :subscriptions => [],
            :queue => [],
          }
          send_message(source, 'OK')

        when 'DISCONNECT'
          @clients.delete(source)
          send_message(source, 'OK')

        when 'SUB'
          @clients[source][:subscriptions] += message
          send_message(source, 'OK')

        when 'UNSUB'
          @clients[source][:subscriptions] -= message
          send_message(source, 'OK')

        when 'PUT'
          topic = message.first
          @clients.values.select { |x| x[:subscriptions].include?(topic) }.each do |client|
            client[:queue] << message
          end
          send_message(source, 'OK')

          @logger.debug "state of the world is now '#{@clients.inspect}"

        when 'GET'
          queue = @clients[source][:queue]
          if queue.empty?
            send_message(source, 'OK', 'WAIT')
          else
            send_message(source, 'OK', 'MESSAGE', *(queue.shift))
          end

          @logger.debug "state of the world is now '#{@clients.inspect}"


        else
          @logger.debug "Don't know how to handle '#{verb}', saying FAIL"
          send_message(source, 'FAIL', 'Unknown verb')
        end
      end
    end
  end

  private

  def status_thread
    @logger.info "Starting status thread"

    while true
      @logger.debug "Currently managing #{@clients.count} clients #{@clients.inspect}"
      sleep 2
    end
  end

  def read_message
    @logger.debug 'going to read message'
    message = []
    assert_zeromq(@socket.recv_strings(message))
    source = message.slice!(0,2)[0]

    @logger.debug "got #{message.inspect} from #{source.inspect}"
    return source, message
  end

  def send_message(target, *message)
    @logger.debug "sending #{message.inspect} to #{target.inspect}"
    @socket.send_strings([ target, '', *message ])
    @logger.debug 'sent message'
  end

  def assert_zeromq(rc)
    return if ZMQ::Util.resultcode_ok?(rc)
    raise "Operation failed, errno [#{ZMQ::Util.errno}] description [#{ZMQ::Util.error_string}]"
  end
end


options = {
  :bind  => 'tcp://*:61616',
}
OptionParser.new do |opts|
  opts.banner = "Usage: middleware [options]"

  opts.on('--bind', 'Address to bind') do |v|
    options[:bind] = v
  end

  opts.on('--curve-private-key=s', 'The curve privatekey') do |v|
    options[:curve_private_key] = v
  end
end.parse!

Middleware.new(options).main_loop
